using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;
using System;
using System.IO;
using System.Linq;

namespace GVFS.PreBuild
{
    public class GenerateGitVersionConstants : Task
    {
        [Required]
        public string GitPackageVersion { get; set; }

        [Required]
        public string PackagesPath { get; set; }

        [Required]
        public string OutputFile {get; set; }

        [Output]
        public string LatestInstaller { get; set; }

        [Output]
        public string LatestInstallerFilename { get; set; }

        public override bool Execute()
        {
            this.Log.LogMessage(MessageImportance.High, "Creating constants for Git package " + this.GitPackageVersion);

            string installerDirectory = Path.Combine(
                this.PackagesPath,
                "GitForWindows.GVFS.Installer." + this.GitPackageVersion,
                "tools");

            if (!Directory.Exists(installerDirectory))
            {
                this.Log.LogError("Git package not found. Re-run your build to allow the package to be downloaded by Visual Studio.");
                return false;
            }

            this.LatestInstaller = Path.GetFullPath(Directory.EnumerateFiles(installerDirectory).Single());
            this.LatestInstallerFilename = Path.GetFileName(this.LatestInstaller);
            GitVersion version;
            if (!GitVersion.TryParseInstallerName(this.LatestInstallerFilename, out version))
            {
                this.Log.LogError("Unable to parse git version: " + this.LatestInstallerFilename);
                return false;
            }

            this.Log.LogMessage(MessageImportance.High, "Found Git version " + version.ToString());

            string projectOutputPath = Path.GetDirectoryName(this.OutputFile);
            if (!Directory.Exists(projectOutputPath))
            {
                Directory.CreateDirectory(projectOutputPath);
            }

            File.WriteAllText(
                this.OutputFile,
                string.Format(
@"// This file is auto-generated by GVFS.PreBuild.GenerateGitVersionConstants. Any changes made directly in this file will be lost.
using GVFS.Common.Git;

namespace GVFS.Common
{{
    public static partial class GVFSConstants
    {{
        public static readonly GitVersion SupportedGitVersion = new GitVersion({0}, {1}, {2}, ""{3}"", {4}, {5});
    }}
}}",
                    version.Major,
                    version.Minor,
                    version.Build,
                    version.Platform,
                    version.Revision,
                    version.MinorRevision));

            return true;
        }

        // This class was partially copied from GVFS.Common.Git.GitVersion for the parsing
        private class GitVersion
        {
            private GitVersion(int major, int minor, int build, string platform, int revision, int minorRevision)
            {
                this.Major = major;
                this.Minor = minor;
                this.Build = build;
                this.Platform = platform;
                this.Revision = revision;
                this.MinorRevision = minorRevision;
            }

            public int Major { get; private set; }
            public int Minor { get; private set; }
            public string Platform { get; private set; }
            public int Build { get; private set; }
            public int Revision { get; private set; }
            public int MinorRevision { get; private set; }

            public static bool TryParseInstallerName(string input, out GitVersion version)
            {
                // Installer name is of the form
                // Git-2.14.1.gvfs.1.1.gb16030b-64-bit.exe

                version = null;

                if (!input.StartsWith("Git-", StringComparison.InvariantCultureIgnoreCase))
                {
                    return false;
                }

                if (!input.EndsWith("-64-bit.exe", StringComparison.InvariantCultureIgnoreCase))
                {
                    return false;
                }

                return TryParseVersion(input.Substring(4, input.Length - 15), out version);
            }

            private static bool TryParseVersion(string input, out GitVersion version)
            {
                version = null;
                int major, minor, build, revision, minorRevision;

                if (string.IsNullOrWhiteSpace(input))
                {
                    return false;
                }

                string[] parsedComponents = input.Split(new char[] { '.' });
                int parsedComponentsLength = parsedComponents.Length;
                if (parsedComponentsLength < 5)
                {
                    return false;
                }

                if (!TryParseComponent(parsedComponents[0], out major))
                {
                    return false;
                }

                if (!TryParseComponent(parsedComponents[1], out minor))
                {
                    return false;
                }

                if (!TryParseComponent(parsedComponents[2], out build))
                {
                    return false;
                }

                if (!TryParseComponent(parsedComponents[4], out revision))
                {
                    return false;
                }

                if (parsedComponentsLength < 6 || !TryParseComponent(parsedComponents[5], out minorRevision))
                {
                    minorRevision = 0;
                }

                string platform = parsedComponents[3];

                version = new GitVersion(major, minor, build, platform, revision, minorRevision);
                return true;
            }

            public override string ToString()
            {
                return string.Format("{0}.{1}.{2}.{3}.{4}.{5}", this.Major, this.Minor, this.Build, this.Platform, this.Revision, this.MinorRevision);
            }

            private static bool TryParseComponent(string component, out int parsedComponent)
            {
                if (!int.TryParse(component, out parsedComponent))
                {
                    return false;
                }

                if (parsedComponent < 0)
                {
                    return false;
                }

                return true;
            }
        }
    }
}

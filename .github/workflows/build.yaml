name: VFS for Git

on:
  pull_request:
    branches: [ master, releases/shipped ]
  push:
    branches: [ reuse-previous-successful-ci-jobs, master, releases/shipped ]
  workflow_dispatch:
    inputs:
      git_version:
        description: 'Microsoft Git version tag to include in the build (leave empty for default)'
        required: false
        type: string

permissions:
  contents: read

env:
  GIT_VERSION: ${{ github.event.inputs.git_version || 'v2.50.1.vfs.0.1' }}

jobs:
  validate:
    runs-on: windows-2025
    name: Validation
    outputs:
      result: ${{ steps.check.outputs.result }}

    steps:
    - name: look for prior successful runs
      id: check
      uses: actions/github-script@v7
      with:
        github-token: ${{secrets.GITHUB_TOKEN}}
        script: |
          /*
            * It would be nice if GitHub Actions offered a convenient way to avoid running
            * successful workflow runs _again_ for the respective commit (or for a tree-same one):
            * We would expect the same outcome in those cases, right?
            *
            * Let's check for such a scenario: Look for previous runs that have been successful
            * and that correspond to the same commit, or at least a tree-same one. If there is
            * one, skip running the build and tests _again_.
            *
            * There are challenges, though: We need to require those _jobs_ to succeed before PRs
            * can be merged. You can mark workflow _jobs_ as required on GitHub, but not
            * _workflows_. So if those jobs are now simply skipped, the requirement isn't met and
            * the PR cannot be merged. We can't just skip the job. Instead, we need to run the job
            * _but skip every single step_ so that the job can "succeed".
            *
            * Further, each of those Functional Test jobs is quite costly. With GitHub's current
            * pools, they take roughly 35 minutes for x86_64, and a whopping 1 hour 15 minutes for
            * ARM64. And all of them fail at times due to flaky tests. Therefore, we need to
            * search on a more granular basis than just successful _workflow runs_: We need to
            * search for successful _workflow jobs_.
            *
            * Also, when a 'Build and Unit Test' job can be skipped but a dependent 'Functional
            * Test' one must be run, we need the link to the 'Build and Unit Test' job so that
            * the respective build artifacts can be obtained, as required for the Functional Tests
            * to run.
            */
            const keys =
              ['Build and Unit Test', 'Functional Tests']
                .flatMap((jobName) =>
                  ['Debug', 'Release']
                    .flatMap((configuration) =>
                      (
                        jobName !== 'Functional Tests'
                        ? [configuration]
                        : ['x86_64', 'arm64'].map((architecture) => `${configuration}, ${architecture}`)
                      ).map((suffix) => `${jobName} (${suffix})`)
                    )
                )
            const result = keys.reduce((a, e) => {
              a[e] = { needsToRun: true }
              return a
            }, { skip: { build: [], functional_test: [] } })
            let countDown = keys.length
            try {
            // Figure out workflow ID, commit and tree
            const { data: run } = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId,
            });
            const workflow_id = run.workflow_id;
            const head_sha = '178616486f62c78503ffd76911f6a084f833356a' // overridden for debugging; should otherwise be run.head_sha;
            const tree_id = 'f4483867e0813dd0a51bf7e88b47e23b48ea30fd' // overridden for debugging; should otherwise be run.head_commit.tree_id;

            // See whether there is a successful run for that commit or tree
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 500,
              workflow_id,
            });
            const demoteInProgressToEnd =
              (a, b) => ((a.status === 'in_progress' ? 1 : 0) - (b.status === 'in_progress' ? 1 : 0))
            for (const run of runs.workflow_runs.sort(demoteInProgressToEnd)) {
              let reason
              if (head_sha === run.head_sha) reason = 'the same commit'
              else if (tree_id === run.head_commit?.tree_id) reason = 'a tree-same commit'
              else continue

              if (run.status === 'in_progress') {
                // poll until the run is done
                const pollIntervalInSeconds = 30
                let seconds = 0
                for (;;) {
                  console.log(`Found existing, in-progress run at ${run.html_url}; Waiting for it to finish (waited ${seconds} seconds so far)...`)
                  await new Promise((resolve) => { setTimeout(resolve, pollIntervalInSeconds * 1000) })
                  seconds += pollIntervalInSeconds

                  const { data: polledRun } = await github.rest.actions.getWorkflowRun({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: run.id
                  })
                  if (polledRun.status !== 'in_progress') break
                }
              }

              const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: run.id
              })
              for (const job of jobs.jobs) {
                if (job.conclusion !== 'success') continue
                const o = result[job.name]
                if (!o || !o.needsToRun) continue

                o.previousSuccessfulRun = job.html_url
                o.reason = reason
                o.downloadFrom = run.artifacts_url
                o.needsToRun = false

                const skipLabel = job.name.replace(/^.*\((.+)\)$/, '$1')
                if (job.name.startsWith('Build')) result.skip.build.push(skipLabel)
                else result.skip.functional_test.push(skipLabel)
                countDown--
              }
              if (!countDown) break
            }
            return result
          } catch (e) {
            core.warning(e);
          }

    - name: Checkout source
      if: ! contains(fromJSON(steps.check.outputs.result).skip.build, 'Debug') ||  ! contains(fromJSON(steps.check.outputs.result).skip.build, 'Release')
      uses: actions/checkout@v5

    - name: Validate Microsoft Git version
      if: ! contains(fromJSON(steps.check.outputs.result).skip.build, 'Debug') ||  ! contains(fromJSON(steps.check.outputs.result).skip.build, 'Release')
      shell: pwsh
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        & "$env:GITHUB_WORKSPACE\.github\workflows\scripts\validate_release.ps1" `
          -Repository microsoft/git `
          -Tag $env:GIT_VERSION && `
        Write-Host ::notice title=Validation::Using microsoft/git version $env:GIT_VERSION

  build:
    runs-on: windows-2025
    name: Build and Unit Test
    needs: validate
    outputs:
      download-from: ${{ steps.skip.outputs.download-from }}

    strategy:
      matrix:
        configuration: [ Debug, Release ]
      fail-fast: false

    steps:
    - name: Skip this job if there is a previous successful run
      if: contains(fromJSON(needs.validate.outputs.result).skip.build, matrix.configuration)
      id: skip
      env:
        JSON: ${{ toJSON(needs.validate.outputs.result) }}
      uses: actions/github-script@v7
      with:
        script: |
          const { downloadFrom, reason, previousSuccessfulRun } = JSON.parse(process.env.JSON)['${{ github.job }}']
          core.setOutput('download-from', downloadFrom)
          core.info(`Skipping: There already is a successful run for ${reason}: ${downloadFrom}`)
          return true

    - name: Checkout source
      if: steps.skip.outputs.result != 'true'
      uses: actions/checkout@v5
      with:
        path: src

    - name: Install .NET SDK
      if: steps.skip.outputs.result != 'true'
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: 8.0.413

    - name: Add MSBuild to PATH
      if: steps.skip.outputs.result != 'true'
      uses: microsoft/setup-msbuild@v2.0.0

    - name: Build VFS for Git
      if: steps.skip.outputs.result != 'true'
      shell: cmd
      run: src\scripts\Build.bat ${{ matrix.configuration }}

    - name: Run unit tests
      if: steps.skip.outputs.result != 'true'
      shell: cmd
      run: src\scripts\RunUnitTests.bat ${{ matrix.configuration }}

    - name: Create build artifacts
      if: steps.skip.outputs.result != 'true'
      shell: cmd
      run: src\scripts\CreateBuildArtifacts.bat ${{ matrix.configuration }} artifacts

    - name: Download microsoft/git installers
      if: steps.skip.outputs.result != 'true'
      shell: cmd
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        gh release download %GIT_VERSION% --repo microsoft/git --pattern "Git*.exe" --dir artifacts\GVFS.Installers

    - name: Upload functional tests drop
      if: steps.skip.outputs.result != 'true'
      uses: actions/upload-artifact@v4
      with:
        name: FunctionalTests_${{ matrix.configuration }}
        path: artifacts\GVFS.FunctionalTests

    - name: Upload FastFetch drop
      if: steps.skip.outputs.result != 'true'
      uses: actions/upload-artifact@v4
      with:
        name: FastFetch_${{ matrix.configuration }}
        path: artifacts\FastFetch

    - name: Upload installers
      if: steps.skip.outputs.result != 'true'
      uses: actions/upload-artifact@v4
      with:
        name: Installers_${{ matrix.configuration }}
        path: artifacts\GVFS.Installers

  functional_test:
    runs-on: ${{ matrix.architecture == 'arm64' && 'windows-11-arm' || 'windows-2025' }}
    name: Functional Tests
    needs: [validate, build]

    strategy:
      matrix:
        configuration: [ Debug, Release ]
        architecture: [ x86_64, arm64 ]
      fail-fast: false # most failures are flaky tests, no need to stop the other jobs from succeeding

    steps:
    - name: Skip this job if there is a previous successful run
      if: contains(fromJSON(needs.validate.outputs.result).skip.functional_test, format('{0}, {1}', matrix.configuration, matrix.architecture))
      id: skip
      env:
        JSON: ${{ toJSON(needs.validate.outputs.result) }}
      uses: actions/github-script@v7
      with:
        script: |
          const { downloadFrom, reason, previousSuccessfulRun } = JSON.parse(process.env.JSON)['${{ github.job }}']
          core.setOutput('download-from', downloadFrom)
          core.info(`Skipping: There already is a successful run for ${reason}: ${downloadFrom}`)
          return true

    - name: Download installers and functional tests drop from previous run
      if: steps.skip.outputs.result != 'true' && env.DOWNLOAD_FROM != ''
      id: download
      env:
        DOWNLOAD_FROM: ${{ needs.build.outputs.download-from }}
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        set -x &&
        e="$(gh api ${DOWNLOAD_FROM#*/repos/} --jq '.artifacts[] | "\(.name)=\(.archive_download_url)" &&')echo That was all, folks" &&
        eval "$e" &&
        download_to() {
          curl -H 'Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}' -Lo "$1".zip "$2" &&
          mkdir "$1" &&
          $WINDIR/system32/tar.exe -C "$1" -xvf "$1".zip
        } &&
        download_to "$Installers_${{ matrix.configuration }}" install &&
        download_to FunctionalTests_${{ matrix.configuration }} ft &&
        echo "result=true" >>$GITHUB_OUTPUT

    - name: Download installers
      if: steps.skip.outputs.result != 'true' && steps.download.outputs.result != 'true'
      uses: actions/download-artifact@v5
      with:
        name: Installers_${{ matrix.configuration }}
        path: install

    - name: Download functional tests drop
      if: steps.skip.outputs.result != 'true' && steps.download.outputs.result != 'true'
      uses: actions/download-artifact@v5
      with:
        name: FunctionalTests_${{ matrix.configuration }}
        path: ft

    - name: ProjFS details (pre-install)
      if: steps.skip.outputs.result != 'true'
      shell: cmd
      run: install\info.bat

    - name: Install product
      if: steps.skip.outputs.result != 'true'
      shell: cmd
      run: install\install.bat

    - name: ProjFS details (post-install)
      if: steps.skip.outputs.result != 'true'
      shell: cmd
      run: install\info.bat

    - name: Upload installation logs
      if: always() && steps.skip.outputs.result != 'true'
      uses: actions/upload-artifact@v4
      with:
        name: InstallationLogs_${{ matrix.configuration }}_${{ matrix.architecture }}
        path: install\logs

    - name: Run functional tests
      if: steps.skip.outputs.result != 'true'
      shell: cmd
      run: |
        SET PATH=C:\Program Files\VFS for Git;%PATH%
        SET GIT_TRACE2_PERF=C:\temp\git-trace2.log
        ft\GVFS.FunctionalTests.exe /result:TestResult.xml --ci

    - name: Upload functional test results
      if: always() && steps.skip.outputs.result != 'true'
      uses: actions/upload-artifact@v4
      with:
        name: FunctionalTests_Results_${{ matrix.configuration }}_${{ matrix.architecture }}
        path: TestResult.xml

    - name: Upload Git trace2 output
      if: always() && steps.skip.outputs.result != 'true'
      uses: actions/upload-artifact@v4
      with:
        name: GitTrace2_${{ matrix.configuration }}_${{ matrix.architecture }}
        path: C:\temp\git-trace2.log

    - name: ProjFS details (post-test)
      if: always() && steps.skip.outputs.result != 'true'
      shell: cmd
      run: install\info.bat
